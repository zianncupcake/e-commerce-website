const User = require("../models/UserModel");
const Review = require("../models/ReviewModel");
const Product = require("../models/ProductModel")
//bcryptjs library --> commonly used for password hashing in nodejs applications
const bcrypt = require("bcryptjs");
//generate salt. 10 represents cost factor / number of rounds of hashing
const salt = bcrypt.genSaltSync(10);

//uses hashsync method to hash password.
const hashPassword = (password) => bcrypt.hashSync(password, salt);
//method provided by bycrpt library. compares plaintext password with hashpassword
const comparePasswords = (inputPassword, hashedPassword) => bcrypt.compareSync(inputPassword, hashedPassword)

const jwt = require("jsonwebtoken");

  const generateAuthToken = (_id, name, lastName, email, isAdmin) => {
    //sign method to create a jwt --> generates jwt based on user's info
    return jwt.sign(
        //payload of the jwt. contains info that u want to encode in the token
      { _id, name, lastName, email, isAdmin },
      //secret key used to sign the jwt --> generated jwt returned by function
      process.env.JWT_SECRET_KEY,
      //optional parameter specifying expiration time of the token
      { expiresIn: "7h" }
    );
  };


const adminGetUsers = async (req, res, next) => {
  try {
    //retrieves all users using find method. since find is empty{} means no specific conditions
    //exclude password field
    const users = await User.find({}).select("-password");
    return res.json(users);
  } catch (err) {
    next(err);
  }
};

const registerUser = async (req, res, next) => {
    //using jsonwebtoken library to generate a json web token -->url-safe means of representing claims to be transferred between 2 parties. used for authentication and information exchange between server and client

  try {
    const { name, lastName, email, password } = req.body;
    if (!(name && lastName && email && password)) {
      return res.status(400).send("All inputs are required");
    }
    //email shorthand in modern js for email:email
    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(400).json({ error: "user exists" });
    } else {
      const hashedPassword = hashPassword(password);
      //create new instance of user model, auto persist to mongodb database, thats why dont need user.save
      const user = await User.create({
        name,
        lastName,
        email: email.toLowerCase(),
        password: hashedPassword,
      });
      //setting a cookie named access token in the http response. the value of this cookie is generated by generateAuthToken function
      //the cookie has additional properties: {}
      res.cookie("access_token", generateAuthToken(user._id, user.name, user.lastName, user.email, user.isAdmin),
          {
            httpOnly: true, //cookie only accessavke through http protocal and not accessible via javascript, security measure
            secure: process.env.NODE_ENV === "production", //in a production environment, cookie set to be transmitted only over https for enhanced security
            sameSite: "strict", //cookie should only be sent in a first party context and not sent along the cross site requests
          }
        )

        //201 status code (created) sent as http response.
        //response indicates details about newly created user

        .status(201)
        .json({
          success: "User created",
          userCreated: {
            _id: user._id,
            name: user.name,
            lastName: user.lastName,
            email: user.email,
            isAdmin: user.isAdmin,
          },
        });
    }
  } catch (err) {
    next(err);
  }
};


//authenticating user based on provided credentials, generate access token, setting it as an http cookie
const loginUser = async (req, res, next) => {
    try {
      const { email, password, doNotLogout } = req.body;
      if (!(email && password)) {
        return res.status(400).send("All inputs are required");
      }
  
      const user = await User.findOne({ email }).orFail();
      if (user && comparePasswords(password, user.password)) {

        //initialise object cookieParams with default cookie settings
        let cookieParams = {
          httpOnly: true,
          secure: process.env.NODE_ENV === "production",
          sameSite: "strict",
        };

        //conditionally adjusting cookie parameters. adjust cookie expiration time for scenarios where user want to stay logged in for longer duration
        if (doNotLogout) {
          cookieParams = { ...cookieParams, maxAge: 1000 * 60 * 60 * 24 * 7 }; // 1000=1ms
        }
        //in express, res.cookie is a method used to set cookies in the http response. instructs client's browser to store a cookie.
        //set cookie names access token with the value generated by generateauthtoken function
        //after setting cookie, json response is sent with a cuess message and user information
        return res.cookie(
          "access_token",
          generateAuthToken(
            user._id,
            user.name,
            user.lastName,
            user.email,
            user.isAdmin
          ),
          cookieParams
        ).json({
            success: "user logged in",
            userLoggedIn: { _id: user._id, name: user.name, lastName: user.lastName, email: user.email, isAdmin: user.isAdmin, doNotLogout }
        });
      } else {
         return res.status(401).send("wrong credentials") 
      }
    } catch (err) {
      next(err);
    }
  };

  const updateUserProfile = async (req, res, next) => {
    try {
        //if provided in body then change value but if not use the current one 
      const user = await User.findById(req.params.id).orFail();
      user.name = req.body.name || user.name;
      user.lastName = req.body.lastName || user.lastName;
      user.email = req.body.email || user.email;
      user.phoneNumber = req.body.phoneNumber;
      user.address = req.body.address;
      user.country = req.body.country;
      user.zipCode = req.body.zipCode;
      user.city = req.body.city;
      user.state = req.body.state;
      if (req.body.password !== user.password) {
        user.password = hashPassword(req.body.password);
      }
      await user.save();
  
      res.json({
        success: "user updated",
        userUpdated: {
          _id: user._id,
          name: user.name,
          lastName: user.lastName,
          email: user.email,
          isAdmin: user.isAdmin,
        },
      });
    } catch (err) {
      next(err);
    }
  };

  const getUserProfile = async (req, res, next) => {
    try {
        const user = await User.findById(req.params.id).orFail();
        return res.send(user);
    } catch(err) {
        next(err)
    }
}

const writeReview = async (req, res, next) => {
    try {
      const {formInputs, user} = req.body;
        //a new mongodb session starts using startsession method --> group related database operations into a transaction
        // const session = await Review.startSession();
        // get comment, rating from request.body:
        // validate request:
        if (!(formInputs.comment && formInputs.rating)) {
            return res.status(400).send("All inputs are required");
        }

        // create review id manually because it is needed also for saving in Product collection
        const ObjectId = require("mongodb").ObjectId;
        const reviewId = new ObjectId();
        //begin new transaction
        // session.startTransaction();
        //session option passed to ensure that the operation is part of the ongoing transaction
        const reviewCreated = (await Review.create([
            {
                _id: reviewId,
                comment: formInputs.comment,
                rating: Number(formInputs.rating),
                user: { id: user._id, name: user.name + " " + user.lastName },
            }
        ]))[0]; //use [0] to access first elemt returned by create. mongoose create method returns an array of creat4ed documents
        //need to populate the reviews because if we never populate, what we store in products.review is only the objectid, so they dont have review field
        //session option provided to associate the query with the ongoing transaction
        const product = await Product.findById(req.params.productId).populate("reviews");

        // const alreadyReviewed = product.reviews.find((r) => r.user.id.toString() === req.user._id.toString());
        // if (alreadyReviewed) {
        //     await session.abortTransaction();
        //     session.endSession();
        //     return res.status(400).send("product already reviewed");
        // }

        let prc = [...product.reviews];
        //avoid directly modifying original array
        //add new item rating into array {{review1},{review2},{rating:rating}}
        prc.push({ rating: formInputs.rating });

        product.reviews.push(reviewCreated);
        console.log("review", reviewCreated)
        console.log("product reviews", product.reviews)
        if (product.reviews.length === 1) {
            product.rating = Number(formInputs.rating);
            product.reviewsNumber = 1;
        } else {
            product.reviewsNumber = product.reviews.length;
            //use reduce function to iterate over product.reviews array, accumulate sum of all individual ratings. 0 is the initial value
            //thats why we need to add rating object into prc. cuz this rating itself is 1 item, the new review. so need to map rating from each item
            product.rating = prc.map((item) => Number(item.rating)).reduce((sum, item) => sum + item, 0) / product.reviews.length;
        }
        await product.save();
        // await session.commitTransaction();
        // session.endSession();
        res.send('review created')
    } catch (err) {
        next(err);
        console.log(err)   
    }
}
const adminGetUser = async (req, res, next) => {
    try {
        const user = await User.findById(req.params.id).select("name lastName email isAdmin").orFail();
        return res.send(user);
    } catch (err) {
       next(err); 
    }
}

const adminUpdateUser = async (req, res, next) => {
    try {
       const user = await User.findById(req.params.id).orFail(); 

        user.name = req.body.name || user.name;
        user.lastName = req.body.lastName || user.lastName;
        user.email = req.body.email || user.email;
        user.isAdmin = req.body.isAdmin 

        await user.save();

        return res.send({user, message: "user updated"});

    } catch (err) {
       next(err); 
    }
}

const adminDeleteUser = async (req, res, next) => {
    try {
        const userExists = await User.findOneAndDelete({_id: req.params.id})
        console.log("req.params.id", userExists)
        if (userExists) {
            res.json({ userDeleted: true }); // json response sent back to client to indicate category successfully deleted
        } else {
            res.status(404).json({ error: 'User not found' });
        }
} catch (err) {
        next(err);
    }
}


module.exports = { adminGetUsers, registerUser, loginUser, updateUserProfile, getUserProfile, writeReview, adminGetUser, adminUpdateUser, adminDeleteUser};

//controller function imports user model from usermodel.js. interacts with user model to create a new user
//http cookie: small piece of data stored on user's computer by web browser while browsing a website. cookies are designed to be a reliable mechanism for websites to remember stateful info or to record the users browsing activity